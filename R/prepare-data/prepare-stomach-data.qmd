---
title: "Prepare stomach content data for Lammska analysis"
author: "Max Lindmark & Viktor Thunell"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    embed-resources: true
    fig-width: 8
    #fig-asp: 0.618
knitr: 
  opts_chunk:
    fig.align: center
editor: source
execute: 
  echo: true
  eval: true
  cache: false
---

## Load libraries

```{r libs}
#| message: false
#| warning: false
library(tidyverse)
library(tidylog)
library(janitor)
library(devtools)
library(sdmTMB)
library(patchwork)
library(terra)

# Import some plotting functions
# Source code for map plots
# You need: devtools::install_github("seananderson/ggsidekick") # not on CRAN; library(ggsidekick)
devtools::source_url("https://raw.githubusercontent.com/maxlindmark/pred-prey-overlap/main/R/functions/map-plot.R")
options(ggplot2.continuous.colour = "viridis")

# Set path
home <- here::here()
```

## Read datan

I downloaded all stomach data from the Baltic, all countries (year 1963-2021), at 16:21  Jan 15 2024. Here's a test script to prepare those data.

The aim of the script is to create a response variable that is the individual level weight ratio of saduria, herring and sprat (separately) to cod. Hence we need, per predator stomach (cod), the total weight (VT:?? or individual) of these species, and if they are absent, weight should be 0 (VT: NA or 0, see code below). We also need coordinates for each cod. To get there, we need to do the following:

1. Read in data
    a. downloaded data from ICES stomach database
    b. complete new with old database data (since large are still not been uploaded)
    c. add additional newer data
2. Filter predators with the above prey present and calculate the total weight of these for each predator
3. Some renaming and data cleaning
4. Filter predators where these prey are not present.
5. Bind rows, and replace NA with 0


```{r read data}
# New database data
fi <- read_csv(paste0(home, "/data/stomach/StomachContent_0115213707/File_information.csv"))
hi <- read_csv(paste0(home, "/data/stomach/StomachContent_0115213707/HaulInformation.csv"))
pred <- read_csv(paste0(home, "/data/stomach/StomachContent_0115213707/PredatorInformation_edit.csv")) #edited in text editor (not excel or equivalent) to remove three instances of erroneous '"' in column 'Notes' at row 7139,7144 and 7296.
prey <- read_csv(paste0(home, "/data/stomach/StomachContent_0115213707/PreyInformation.csv"))

# Old database data
old_db <- read_csv(paste0(home, "/data/stomach/StomachDataOld.csv")) 

# New data
# new_db <- read_csv(paste0(home, "/data/stomach/StomachDataNew.csv")) #edited in text editor (not excel or equivalent) to remove three instances of erroneous '"' in column
```

Start with new database data. Have a look at the data... The description of the data can be found here: <http://datsu.ices.dk/web/selRep.aspx?Dataset=157>

```{r quick glimpse}
names(fi)
names(hi)
names(pred)
names(prey)
```

## Join all data files
We do this in a specific order: fi -> hi -> pred -> prey.

For some joins, there are multiple column names shared in addition to the key that I could remove and keep only the ID key and the non-shared columns but instead I keep them. First I need to ensure they are the same (VT what is the same and how do you do this?), and not only have the same name. Will also check if both datasets have the same amount of NA before choosing which column to carry from which dataset.

```{r}
hi <- left_join(hi, fi, by = "tblUploadID")

comcol_hi_pred <- intersect(colnames(pred), colnames(hi))

# Check if any of the two datasets have NA in the common columns
unique(is.na(hi |> dplyr::select(all_of(comcol_hi_pred))))
unique(is.na(pred |> dplyr::select(all_of(comcol_hi_pred))))

# Nope, but the column Notes does have different meanings so we will remove Notes before joining
str(prey)
pred <- left_join(pred |> dplyr::select(-Notes),
                  hi |> dplyr::select(-Notes),
                  by = comcol_hi_pred[!comcol_hi_pred == "Notes"])
```

```{r}
# Quick test!
ggplot(pred |> filter(!Year == 2018), aes(IndWgt)) +
  facet_wrap(~Country, scales = "free") +
  geom_histogram()
```

Now let's join predator data to prey data following the same procedure.

```{r}
intersect(colnames(pred), colnames(prey))

# Length is a common column, but it corresponds to predator or prey. Rename!
pred <- pred |> rename(pred_length = Length)
prey <- prey |> rename(prey_length = Length)

comcol_prey_pred <- intersect(colnames(pred), colnames(prey))

# Check if any of the two datasets have NA in the common columns
unique(is.na(pred |> dplyr::select(all_of(comcol_prey_pred))))
unique(is.na(prey |> dplyr::select(all_of(comcol_prey_pred))))

# Rename "Notes" in prey data to avoid confusion as to which dataset it belongs to
prey <- prey |> rename(prey_notes = Notes)

# In the Swedish data, 2 means regurgitated and 1 is intact, but for the rest, 1 means regurgitated, 0 or NA means intact... We want three levels, 1, 0 and NA. NA being empty stomachs for which we don't know if they are regurgitated or not. 1611 NAs in the data set 
pred <- pred |>
  mutate(Regurgitated_st = Regurgitated,
    #     Regurgitated_st = replace_na(Regurgitated_st, 0), 
         Regurgitated_st = ifelse(Country == "SE" & Regurgitated_st == 2, 1, Regurgitated_st))

# Regurgitated stomachs are only about 2% and come exclusively from 2021, 2018 and 2013. The NAs are from 2020 and 2021.
pred |>
  group_by(Year, Regurgitated_st) |>
  summarize(count = n())
# VT: Why do we need a globally unique predator ID when the ICES database download provides the ´tblPredatorInformationID´ which is a unique identifier. Creating this new identifier did however reveal that there are likely duplicates in the data. The FishID is not unique. Adding 'AphiaIDpredator' (not only cod are predators in the data) and 'IndWgt' 
# pred <- pred |> mutate(fish_id = paste(Year, Month, HaulNo, Day, FishID, AphiaIDPredator, IndWgt, sep = "_"))

# length(unique(pred$tblPredatorInformationID))
# length(unique(pred$fish_id)) 
# pred |>
#   select(-tblPredatorInformationID) |> 
#   group_by(fish_id) |>
#   filter(n() > 1) |>
#   ungroup()

# pred |>
#   select(-c(tblPredatorInformationID, Regurgitated)) |> 
#   group_by_all() |>
#   filter(n() > 1) |>
#   ungroup()

# The fish_id is shorter by 43 fish. Some (37) of these fish are be duplicates with respect to all columns but 'tblPredatorInformationID'. the remaining 6 are duplicates with respect to all columns but 'tblPredatorInformationID' and 'Regurgitated'. I.e. there are 6 fish that are both regurgitated and not regurgitated. Remove the 37 duplicates and keep the 6 as not regurgitated (later below):

dups <- pred |> select(-tblPredatorInformationID) |> duplicated() |> which()
pred <- pred[-dups,]

d <- left_join(prey, pred, by = c(comcol_prey_pred))

# Remove regurgitated stomachs! (approx. 3% using the database data)
# pred <- pred |>
#   filter(Regurgitated_st == 0)

# TODOne? VT: I dont see this in the database data when duplicates and 1/0 regurgs has been removed: Here we can see that if we filter the prey file to only have the predators that have regurgitated stomachs, there are still prey-weights. So sometimes they are analyzed! VT We use the prey file for calculating stuff and they fill that with info about their predators, empties and regurgs are then a different story.
# regurg_ids <- 
# pred |>
#   filter(!Regurgitated_st == 0)
# prey |> filter(tblPredatorInformationID %in% c(regurg_ids$PredatorInformationID)) |> distinct(Weight, AphiaIDPrey) |> as.data.frame()
# 
# d |> 
#   group_by(Regurgitated_st) |>
#   summarise(n = n())

# Check the predator id's that are not in the prey file. What do they have in common? They are all empty. 
# We will have two categories of empty: empty-empty, and empty with respect to sprat, herring and saduria. The frst category will also have 3 sub categories, regurgs or not and NAas (unknown reason why they are empty, pre mid 80s, see Neuenfeldt 2020 methods)
# empty_stom <- pred |> 
#   filter(!tblPredatorInformationID %in% unique(prey$tblPredatorInformationID))
# 
# empty_stom |> 
#   distinct(Regurgitated_st, StomachEmpty, StomachFullness, FullStomWgt, EmptyStomWgt)
```

## Calculate total weight of specific prey species by unique predator ID

Next we need to summarize our prey weights by predator and prey group. First filter stomachs where these prey (herring, sprat and saduria) are present. Create a new common name column to make life easier... 

```{r}
#| message: false

selected_prey_named <- d |> 
  mutate(common_prey_name = NA,
         common_prey_name = ifelse(AphiaIDPrey %in% c(293743, 1625944, 126425, 322683, 236448), "sprat", common_prey_name),
         common_prey_name = ifelse(AphiaIDPrey == 126417, "herring", common_prey_name),
         common_prey_name = ifelse(AphiaIDPrey %in% c(293511, 119034), "saduria", common_prey_name),
         common_prey_name = ifelse(!AphiaIDPrey %in% c(293743, 1625944, 126425, 322683, 236448, 126417, 293511, 119034), "other", common_prey_name)) ## |> 
  #filter(common_prey_name %in% c("sprat", "herring", "saduria"))

# The Regurgitated_st and StomachEmpty are still in the data so I need to add the nonEmpty
# empty_stom <- d |> 
#   filter(!tblPredatorInformationID %in% unique(selected_prey_present$tblPredatorInformationID))
# empty_stom |>
# filter(AphiaIDPrey %in% c(293743, 1625944, 126425, 322683, 236448, 126417, 293511, 119034))

# Negative numbers are likely because they couldn't be counted only weighed
#selected_prey_present |> distinct(Count) |> arrange(Count)
#VT: no zero weights in the data from ices 15/1 2024! Ifgthere are zeros, Max finds NAs make more sense to have zeros could be rounding errors because they are present, whereas the former could be because it simply wasn't weighed)
selected_prey_named |> filter(Weight == 0)
```

For NA weights, we estimate weight. If length is not `NA` and Weight is 0 or NA, estimate weight based on length and Count. Else give weight `NA` and drop it. Because these are not true empty, else there wouldn't be species-information

```{r}
# Estimate weight based on count. In the data, if count is >1, the weight is grouped.  In some cases, all of Weight, Count and prey_length is NA, i.e. there are presences of prey but no information for calculating the total weight. VT: Sometimes thee is a length but no count (0) which we will treat as one and retrieve a weight, I think this is less wrong.

#t_na <- selected_prey_present |> filter(is.na(Weight) & is.na(Count) & is.na(prey_length))
#selected_prey_present |>  filter(prey_length > 0 & Count == 0 & Weight <= 0)

# Calculate weight of prey given count and prey length
selected_prey_named <- selected_prey_named |> 
  mutate(prey_length = ifelse(UnitLngt == "mm", prey_length/10, prey_length)) |> 
  mutate(Weight = replace_na(Weight, -9),
         Count = replace_na(Count, -9),
         prey_length = replace_na(prey_length, -9)) |> # Because we have a mix of negative values and NAs, I chose one of the two options
  mutate(Count = ifelse(prey_length > 0 & Count <= 0, 1, Count)) |> # VT When there is a prey_length but Count <= 0
  mutate(prey_weight_source = ifelse(Weight <= 0 & prey_length > 0 & Count >= 0 , "estimated", "observed")) |> 
  mutate(Weight = ifelse(prey_weight_source == "estimated", (0.01*prey_length^3)*Count, Weight))

selected_prey_named |> filter(common_prey_name %in% c("sprat", "herring", "saduria")) |>
  filter(Weight <= 0) |> select(Weight, prey_length, Count) |> unique()
# TODOld: Even if we estimate the prey weight based on the length of the prey and the number of the prey, we still have 17% (VT: <1% now) of rows in this data with saduria, herring and sprat that does not have any weight information, even though they were clearly present in the data. I guess this is because they couldn't be measured or weighed or counted. Which seems fair. For our purpose, it would probably be less wrong to give them the average weight rather than treating them as 0s if we know the count (else we simply do not know based on length alone). VT: OR as its so few (4) we remove them and avg weight may produce outliers when the predator is small compared to the avg prey size?
prey_avg_ind_weight <- selected_prey_named |>
  filter(Weight > 0 & Count > 0) |>
  group_by(common_prey_name) |>
  mutate(ind_weight = Weight / Count)

# Of course there are obvious issues....  VT: what issues do you see Max aprt from the extreme wights?
prey_avg_ind_weight |>
  ggplot(aes(ind_weight)) +
  facet_wrap(~common_prey_name, ncol = 3, scales = "free") +
  geom_histogram()

# TODO: 893 g sprat? Doubt it! 
prey_avg_ind_weight |>
  filter(common_prey_name == "sprat") |> 
  filter(ind_weight > 100) |> as.data.frame() 

# TODOVT: Saduria above 10 g, Doubt it! 
prey_avg_ind_weight |>
  filter(common_prey_name == "saduria") |> 
  filter(ind_weight > 10) |> as.data.frame() 
#VT: Many saduria is way off, mean weights of 1 g. max weight of 7,8 or 9? (https://doi.org/10.1111/j.0021-8790.2004.00800.x and https://www.jstor.org/stable/24831823 ) . Can be calcluated from Sharkweb data. how to deal with the outliers?

# Remove it (VT: what?), summarize and take average
prey_avg_ind_weight <- prey_avg_ind_weight |>
  #filter(!(common_prey_name == "sprat" & ind_weight > 800)) |> #remove the big saduria
  #filter(!(common_prey_name == "saduria" & ind_weight > 10)) |> #remove the big saduria
  group_by(common_prey_name) |> 
  summarise(avg_weight = mean(ind_weight))

# This should be the average prey weight which we can use to calculate the weight of these prey if we have the counts. Left join that summarized data and do the estimate of weight based on length. But first figure out which unit prey size is

# Join average weight and estimate weight
selected_prey_named_clean <- selected_prey_named |> 
  left_join(prey_avg_ind_weight) |> 
  mutate(Weight = ifelse(Weight <= 0 & Count > 0, Count * avg_weight, Weight))

# Remove the negative weights (VT 283 rows, 1%)! Keep the ID's though because we also want to remove these from the full data set so that we don't inflate the total number of empty stomachs, because these are not actually empty. #This removes 33 rows
ids_to_remove <- selected_prey_named_clean |> filter(Weight <= 0)
ids_to_remove |> as.data.frame() |> distinct(Weight, prey_length, Count)

selected_prey_named_clean <- selected_prey_named_clean |> filter(Weight >= 0)

# TODO: really, can't be 0 count or 0 length or 0 weight... Has to be NA comon
```

With these estimates of weight based on either length or worst case, average weight of that prey, we need to drop 685 rows in the presence data (around 7%). Now calculate the total weight of these prey per individual predator stomach, and then pivot wider. Set `values_fill = 0` to make not present species in a stomach 0 and not NA.

```{r}
selected_prey_named_summed <- selected_prey_named_clean |> 
  group_by(tblPredatorInformationID, common_prey_name) |> 
  summarise(tot_weight = sum(Weight)) |> 
  ungroup()

selected_prey_named_summed <- selected_prey_named_summed |> 
  pivot_wider(names_from = "common_prey_name", values_from = "tot_weight", values_fill = 0)
```

Next I will `left_join` in the remaining predator information, and after that `bind_rows` "empty stomachs" (with respect to these 3 prey species). Since the IDs are not overlapping, it doesn't matter that I already have some 0's here for some species

```{r}
selected_prey_named_summed <- 
  selected_prey_named_summed |> 
  left_join(pred, by = "tblPredatorInformationID") |> 
  drop_na(pred_length) # VT: hmmmh. wonder whag of this is valid still: 167 predators exist only in the "select_prey_present_summed", because pred has filtered away regurgitated stomachs.. The reason they are in "selected_prey_present_summed" is because that dataframe comes from "d", which is left_join(prey, pred), and "prey" contains predator id's even though they have regurgitated stomachs, as shown above

t <- selected_prey_named_summed |>
  select("other","saduria","herring","sprat") |>
  rowSums() == 0
which(t) # one empty stomach..
```

Now add in the "empty stomachs" using bind_rows. When I `bind_rows`, the columns that are not matching get `NA`. The only column not matching should be the average weight columns. They will get `NA`, and I'll change it to 0.

```{r}

# The empty stomachs to be added are those that are empty in predator data. For data before 1985(?) we have no info on whether they are regurgitated or empty because of not eating. For an analysis using all data (1963-) we need to keep n mind why stomachs are empty. 
# Because of the issue of (VT: not?) getting prey weight even though they are present above, we need to make sure to drop these stomachs in the full data set also before joining, so that we don't treat them as empty!

# To remove regurgitated stomachs
# pred <- pred |>
#    filter(Regurgitated_st == 0)

# VT StomachEmpty = 1 is an empty stomach. I remove StomachEmtpy = 0 (not empty stomachs) that are not in preyinfo. I do this not to risk inflating zeros when assuming that all predators in PredatorInfo that do not exist in PreyInfo are emtpy. Max says this has to do with regurgitation. 

#Non empty_stomachs 
pred |> # By remove regurgitated stomachs and not empty stomachs, there are no predators that are unique to the prey data. I.e. No overlap in  predator individuals between the predator and prey data sets if we remove both empt.
 #filter(Regurgitated_st == 0 | is.na(Regurgitated_st)) |>
 filter(StomachEmpty == 1) |>
 filter(!tblPredatorInformationID %in% unique(prey$tblPredatorInformationID))

#Solution is to remove all regurgitated stomachs and the remaining empty stomach (tblpredatorId is 62505 and doe snot have aby prey in the preydata)
empty_stom <- 
pred |> 
 filter(Regurgitated_st == 0 | is.na(Regurgitated_st)) |>
 filter(StomachEmpty == 1) |>
 filter(!tblPredatorInformationID %in% unique(prey$tblPredatorInformationID))

# # These are the empty stomachs with respect to sprat, herring, saduria
# empty <- pred |>
#   filter(!tblPredatorInformationID %in% unique(ids_to_remove$tblPredatorInformationID)) |> # First remove the stomachs that are not truly empty, but we can't estimate the total weight
#   filter(!tblPredatorInformationID %in% c(selected_prey_present_summed$tblPredatorInformationID)) |> # Remove the ones that are not empty but in fact contain sprat, herring or saduria
#   filter(!tblPredatorInformationID %in% c(empty_stom$tblPredatorInformationID)) # Remove the totally empty stomachs
# 
# empty |> distinct(tblPredatorInformationID) |> nrow()

#unique(empty$pred_length)

# Bind rows!
dd <- selected_prey_named_summed |> 
  #bind_rows(empty) |> 
  bind_rows(empty_stom)

unique(is.na(empty_stom$pred_length))
#unique(is.na(empty$pred_length))
unique(is.na(selected_prey_named_summed$pred_length))
unique(is.na(dd$pred_length))
#dd |> drop_na(pred_length)

# Yes, works as intended, see the added NAs in the selected prey weights. Make them 0!
unique(is.na(dd))

# Remove non cod predators (e.g. Whiting 126438)
dd <- dd |> filter(AphiaIDPredator %in% c(126436))

dd <- dd |> 
  mutate(other = replace_na(other, 0),
         sprat = replace_na(sprat, 0),
         herring = replace_na(herring, 0),
         saduria = replace_na(saduria, 0))
```

Now summarise and plot these data. First calculate the feeding ratio, which is the weight of prey over predator weight

```{r}
unique(is.na(dd$IndWgt))
min(dd$IndWgt, na.rm = TRUE)
dd |> distinct(IndWgt) |> arrange(IndWgt)
unique(is.na(dd$pred_length))

ggplot(dd, aes(IndWgt)) + 
  facet_wrap(~Year, scales = "free") +
  geom_histogram()

# TODO: What is going with Denmark? They report in kg
ggplot(dd, aes(IndWgt)) + 
  facet_wrap(~Country, scales = "free") + 
  geom_histogram()

# TODO: What is going with Sweden? They report in mm
ggplot(dd, aes(pred_length)) + 
  facet_wrap(~Country, scales = "free") + 
  geom_histogram()

dd <- dd |> 
  mutate(pred_length = ifelse(Country == "SE", pred_length/10, pred_length)) |> 
  mutate(IndWgt = ifelse(Country == "DK", IndWgt*1000, IndWgt))

# Check again
ggplot(dd, aes(IndWgt)) + 
  facet_wrap(~Country, scales = "free") + 
  geom_histogram()

ggplot(dd, aes(pred_length, fill = Country)) + 
  facet_wrap(~Country, scales = "free") + 
  geom_histogram()

# Estimate predator weight if we got the predator length?
ggplot(dd, aes(pred_length, IndWgt)) + 
  geom_point()

dd <- dd |> 
  mutate(IndWgt = replace_na(IndWgt, 0),
         pred_weight_source = ifelse(IndWgt <= 0, "estimated", "observed"),
         IndWgt = ifelse(pred_weight_source == "estimated", 0.01*pred_length^3, IndWgt))
str(dd)# |> levels(pred_weight_source)

dd |> 
  #filter(pred_weight_source %in% "estimated") |>
  ggplot(aes(pred_length, IndWgt, shape = pred_weight_source)) + 
  geom_point(shape = 4)
```

Now calculate feeding ratios of cod. 

```{r}
# Calculate feeding ratios
dd <- dd |> 
  rowwise() |> 
  mutate(fr_sad = saduria / IndWgt,
          fr_spr = sprat / IndWgt,
          fr_her = herring / IndWgt,
          fr_oth = other / IndWgt,
          fr_tot = sum(other, saduria, sprat, herring) / IndWgt)

dd |> 
  dplyr::select(fr_sad, fr_spr, fr_her, fr_oth, fr_tot) |> 
  pivot_longer(everything()) |> 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_wrap(~name, ncol = 1, scales = "free")

dd |> filter(fr_her > 1) |> as.data.frame()

dd <- dd |>
  filter(fr_spr < 0.5) |> 
  filter(fr_her < 0.5) |> 
  filter(fr_sad < 0.5) |> 
  filter(fr_oth < 0.5) |> 
  filter(fr_tot < 0.5)
```

Check the proportion of stomachs without these prey

```{r}
dd %>% 
  pivot_longer(c("herring", "saduria", "sprat")) |> 
  group_by(name) |> 
  summarise(prop_empty = sum(value == 0)/n(), 
            prop_not_empty = sum(value != 0)/n())
```
VT: ??
Seems like fairly high proportions of cod without these key species in stomachs, but again, this is just from memory.


Now add in Stefan Neuenfeldts data, add in and remove duplicates

```{r}
# old <- read_csv(paste0(home, "/data/clean/stefan_stomachs.csv")) |> 
#   dplyr::select(FR_sad, FR_spr, FR_her, X, Y, year, month, day, pred_weight, pred_size, saduria, sprat, herring,
#                 lat, lon, square, stom_id) |>
#   rename(ices_rect = square, 
#          pred_length = pred_size) |> 
#   drop_na(FR_sad) |> 
#   drop_na(FR_spr) |> 
#   drop_na(FR_her) |> 
#   drop_na(pred_weight)
# 
# # length(which(pred$latP == "NULL"))
# names(old)
# old$stom_id # TODO: careful here, there are NA's in the column that calculates the id, so they might be different fish actually
# 
# names(dd)
# 
# # Fix some columns in the main data before merging
# dd <- dd |> 
#   rename(lon = ShootLong,
#          lat = ShootLat) |>
#   janitor::clean_names() |>
#   rename(ices_rect = ice_srectangle, 
#          FR_spr = fr_spr,
#          FR_her = fr_her,
#          FR_sad = fr_sad,
#          pred_weight = ind_wgt) |> 
#   mutate(month = as.character(month),
#          day = as.character(day)) |> 
#   add_utm_columns(ll_names = c("lon", "lat"), utm_crs = 32633) |> 
#   dplyr::select(FR_sad, FR_spr, FR_her, X, Y, year, month, day, pred_weight, pred_length,
#                 saduria, sprat, herring, lat, lon, ices_rect, depth)
# 
# # are there new data in the old period that is not in stefans data?
# new_old <- dd |> filter(year < 2017)
# 
# new_old <- new_old |> mutate(sample_id = paste(year, month, day, ices_rect, sep = "_"))
# 
# old <- old |> mutate(sample_id = paste(year, month, day, ices_rect, sep = "_"))
# 
# new_old <- new_old |> filter(!sample_id %in% unique(old$sample_id)) |> as.data.frame()
# 
# # Make full dataset
# df <- bind_rows(old, new_old, dd)

```


```{r}
#| out-width: 100%

# Fix some columns
df <- dd |> 
  rename(lon = ShootLong,
         lat = ShootLat,
         ices_rect = ICESrectangle,
         pred_weight = IndWgt) |> 
  mutate(Month = as.character(Month),
         Day = as.character(Day),
         ices_subd = ices.rect2(lon, lat),) |> 
  add_utm_columns(ll_names = c("lon", "lat"), utm_crs = 32633) |> 
  dplyr::select(fr_sad, fr_spr, fr_her, fr_oth, fr_tot, Year, Month, Day, pred_weight, pred_length, saduria, sprat, herring, lat, lon, ices_rect, ices_subd, X, Y)#, depth)

# Add quarter
# df <- df |> 
#   mutate(quarter = ifelse(Month == c(1,2,3), 1, 
#                           ifelse(Month == c(4,5,6), 2, 
#                                  ifelse(Month == c(7,8,9), 3, 4))))

# Add sample size per coordinate for plotting
df_plot <- df |>
  group_by(Year, Y, X) |> 
  mutate(sample_size = n(),
         pos_id = paste(Year, X, Y)) |> 
  ungroup() |> 
  distinct(pos_id, .keep_all = TRUE)
  
plot_map_fc +
  geom_point(data = df_plot, aes(X*1000, Y*1000, size = sample_size), alpha = 0.5) +
  facet_wrap(~ Year, ncol = 6) +
  #theme_sleek(base_size = 6) + 
  theme(legend.position = "bottom",
        axis.text.x = element_text(angle = 90)) +
  scale_size(range = c(.01, 2), name = "# stomachs") +
  geom_sf()

ggsave(paste0(home, "/figures/supp/year_diet_map.pdf"), width = 15, height = 15, units = "cm")
```

Add depth

```{r}
dep_raster <- terra::rast(paste0(home, "/data/Mean depth natural colour (with land).nc"))
class(dep_raster)
crs(dep_raster, proj = TRUE)

plot(dep_raster)

df$depth <- terra::extract(dep_raster, df |> dplyr::select(lon, lat))$elevation

ggplot(df, aes(lon, lat, color = depth*-1)) + 
  geom_point()

df$depth <- df$depth*-1

# TODO: these coordinates are waaay off
df <- df |> drop_na(depth)

df |> 
  ggplot(aes(X*1000, Y*1000, color = depth)) + 
  geom_point() +
  NULL

hist(df$depth)

plot_map_fc +
  geom_point(data = df, aes(X*1000, Y*1000, color = depth), alpha = 0.5) +
  theme_sleek(base_size = 6) + 
  geom_sf()

ggplot(df, aes(lon, lat, color = depth)) + 
  geom_point() + 
  coord_sf()
```

VT: Old. See to TODO-list in code, and also: at which stage do I filter empty stomachs? Now it's just if they aren't present in the prey data, but there's a lot of processing and maybe I should filter later to not inflate the 0's...

Temporal resolution
```{r}

pred |>
  group_by(Year) |>
  summarize(count = n()) |>
  ggplot(aes(Year, count)) +  geom_bar(stat="identity") + ylab("#stomachs in ICES database") 

df |>
  group_by(Year) |>
  summarize(count = n()) |>
  ggplot(aes(Year, count)) +  geom_bar(stat="identity")
```

```{r}
# Save data
write_csv(df, paste0(home, "/data/clean/stomachs.csv"))
```

```{r}
#| echo: false
#| eval: false
renderthis::to_pdf(paste0(here::here(), "/R/prepare-data/01-test-prepare-stomach-data.html"))
```