---
title: "Lammska cod covariate input to data"
author: "Max Lindmark & Viktor Thunell"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    embed-resources: true
    fig-width: 8
    #fig-asp: 0.618
knitr: 
  opts_chunk:
    fig.align: center
editor: source
execute: 
  echo: true
  eval: true
  cache: false
---

## Libraries

```{r lib}
#| message: false

pkgs <- c("tidyverse", "tidylog", "sp", "raster", "devtools", "RCurl", "sdmTMB", "terra", "ncdf4", "chron", "ncdf4") 

if(length(setdiff(pkgs, rownames(installed.packages()))) > 0){

    install.packages(setdiff(pkgs, rownames(installed.packages())), dependencies = T)
  
}

invisible(lapply(pkgs, library, character.only = T))

# Source code for map plots
devtools::source_url("https://raw.githubusercontent.com/VThunell/Lammska_cod-fr/main/R/functions/map-plot.R")
# Packages not on CRAN
# # devtools::install_github("seananderson/ggsidekick") # not on CRAN 
# library(ggsidekick)
# theme_set(theme_sleek())

# Set path
home <- here::here()
```


## 2 Read data

```{r}
#| message: false
#| warning: false

dat <- read_csv(paste0(home, "/data/clean/stomachs3.csv")) |>
  mutate(year_f = as.factor(year),
         month_f = as.factor(month),
         ices_rect = as.factor(ices_rect),
         pred_length_sc = (pred_length - mean(pred_length)) / sd(pred_length),
         doy_sc = ifelse(!is.na(day_of_year), (day_of_year - mean(day_of_year, na.rm = TRUE))/sd(day_of_year, na.rm = TRUE), NA)) |> 
  rowwise() |> 
  mutate(tot = sum(other, other_invert, other_fish, saduria, sprat, herring)
)

glimpse(dat)

# pred_grid_cod <- bind_rows(read_csv(paste0(home, "/data/clean/pred_grid_(1_2)_max.csv")),
#                        read_csv(paste0(home, "/data/clean/pred_grid_(2_2)_max.csv")))

```

# Add depth

```{r}
## Add depth

dep_raster <- terra::rast(paste0(home, "/data/Mean depth natural colour (with land).nc"))
class(dep_raster)
crs(dep_raster, proj = TRUE)

plot(dep_raster)

dat$depth <- terra::extract(dep_raster, dat |> dplyr::select(lon, lat))$elevation

ggplot(dat, aes(lon, lat, color = depth*-1)) + 
  geom_point()

dat$depth <- dat$depth*-1

# TODO: these coordinates are waaay off
# This remoes 8349 rows
dat <- dat |> drop_na(depth) 

dat |> 
  ggplot(aes(X*1000, Y*1000, color = depth)) + 
  geom_point() +
  NULL

hist(dat$depth)

#remove points outside the baltic, i.e. the western most points in:
dat |>
  ggplot(aes(lon, lat, color = depth)) + 
  geom_point() + 
  geom_vline(xintercept = 13) +
  coord_sf()

dat <- dat |>
  filter( lon > 13)

plot_map_fc +
  geom_point(data = dat, aes(X*1000, Y*1000, color = depth), alpha = 0.5) +
  theme_sleek(base_size = 6) + 
  geom_sf()

```

## Add in the environmental variables

```{r add env vars}
# Only need 1 row per haul
dat <- dat %>%
  mutate(month_year = paste(month, year, sep = "_")) #|>
  
dat_haul <- dat |>
  mutate(haul.id = paste(month_year, lat, lon, sep = "_")) |>
  distinct(haul.id, .keep_all = TRUE) |> 
  dplyr::select(lat, lon, year, month, month_year) #|>

# This is our looping index in for loops adding environmental variables below : 
dat_haul_month_year <- dat_haul |> filter( year > 1992 & year < 2022) |> distinct(month_year) |> pull(month_year) 

```


#### Oxygen

```{r oxygen}
# Downloaded from here: https://data.marine.copernicus.eu/products
# Extract raster points: https://gisday.wordpress.com/2014/03/24/extract-raster-values-from-points-using-r/comment-page-1/
# https://rpubs.com/boyerag/297592
# https://pjbartlein.github.io/REarthSysSci/netCDF.html#get-a-variable
# Open the netCDF file
ncin <- nc_open(paste0(home, "/data/NEMO/cmems_mod_bal_bgc_my_P1M-m_1691065496556.nc"))

print(ncin)

# Get longitude and latitude
lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon)
head(lon)

lat <- ncvar_get(ncin,"lat")
nlat <- dim(lat)
head(lat)

# Get time
time <- ncvar_get(ncin,"time")
time

tunits <- ncatt_get(ncin,"time","units")
nt <- dim(time)
nt
tunits

# Get oxygen
dname <- "o2b"

oxy_array <- ncvar_get(ncin,dname)
dlname <- ncatt_get(ncin,dname,"long_name")
dunits <- ncatt_get(ncin,dname,"units")
fillvalue <- ncatt_get(ncin,dname,"_FillValue")
dim(oxy_array)

# Get global attributes
title <- ncatt_get(ncin,0,"title")
institution <- ncatt_get(ncin,0,"institution")
datasource <- ncatt_get(ncin,0,"source")
references <- ncatt_get(ncin,0,"references")
history <- ncatt_get(ncin,0,"history")
Conventions <- ncatt_get(ncin,0,"Conventions")

# Convert time: split the time units string into fields
tustr <- strsplit(tunits$value, " ")
tdstr <- strsplit(unlist(tustr)[3], "-")
tmonth <- as.integer(unlist(tdstr)[2])
tday <- as.integer(unlist(tdstr)[3])
tyear <- as.integer(unlist(tdstr)[1])

# Here I deviate from the guide a little bit. Save this info:
dates <- chron(time, origin = c(tmonth, tday, tyear))

# Crop the date variable
months <- as.numeric(substr(dates, 2, 3))
years <- as.numeric(substr(dates, 8, 9))
years <- ifelse(years > 90, 1900 + years, 2000 + years)

# Replace netCDF fill values with NA's
oxy_array[oxy_array == fillvalue$value] <- NA

dim(oxy_array)
str(dim(oxy_array))
# The third slot is the date index

# Loop through all "dates", put into a list 
dlist <- list()


for(i in 1:length(months)) {
  
  oxy_sub <- oxy_array[, , i]
    
  dlist[[i]] <- oxy_sub
  
}

# Name the list
names(dlist) <- paste(months, years, sep = "_")
str(dlist)

# Create data holding object
oxy_data_list <- list()

# Loop through each month_year and extract raster values for the cpue data points
for(i in dat_haul_month_year) {
  
  # Set plot limits
  ymin = 54; ymax = 58; xmin = 12; xmax = 22


  # Subset a month-year combination
  oxy_slice <- dlist[[i]]
  
  # Create raster for that year (i)
  r <- raster(t(oxy_slice), xmn = min(lon), xmx = max(lon), ymn = min(lat), ymx = max(lat),
              crs = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
  
  # Flip...
  r <- flip(r, direction = 'y')
  
  plot(r, main = paste(i), ylim = c(ymin, ymax), xlim = c(xmin, xmax))


  # Filter the same year (i) in the cpue data and select only coordinates
  d_slice <- dat_haul %>% filter(month_year == i) %>% dplyr::select(lon, lat)
  
  # Make into a SpatialPoints object
  data_sp <- SpatialPoints(d_slice)
  
  # Extract raster value (oxygen)
  rasValue <- raster::extract(r, data_sp)
  
  # Now we want to plot the results of the raster extractions by plotting the cpue data points over a raster and saving it for each year.
  # Make the SpatialPoints object into a raster again (for plot)
  df <- as.data.frame(data_sp)
  
  # Add in the raster value in the df holding the coordinates for the cpue data
  d_slice$oxy <- rasValue
  
  # Add in which year
  d_slice$month_year <- i

  # Now the unit of oxygen is mmol/m3. I want it to be ml/L. The original model is in unit ml/L
  # and it's been converted by the data host. Since it was converted without accounting for
  # pressure or temperature, I can simply use the following conversion factor:
  # 1 ml/l = 103/22.391 = 44.661 Î¼mol/l -> 1 ml/l = 0.044661 mmol/l = 44.661 mmol/m^3 -> 0.0223909 ml/l = 1mmol/m^3
  # https://ocean.ices.dk/tools/unitconversion.aspx

  d_slice$oxy <- d_slice$oxy * 0.0223909
    
  # Add each years' data in the list
  oxy_data_list[[i]] <- d_slice

}

# Now create a data frame from the list of all annual values
big_dat_oxy <- dplyr::bind_rows(oxy_data_list)
```

#### Temperature

```{r temperature}
# Open the netCDF file
ncin <- nc_open(paste0(home, "/data/NEMO/cmems_mod_bal_phy_my_P1M-m_1691065935335.nc"))
                                        
print(ncin)

# Get longitude and latitude
lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon)
head(lon)

lat <- ncvar_get(ncin,"lat")
nlat <- dim(lat)
head(lat)

# Get time
time <- ncvar_get(ncin,"time")
time

tunits <- ncatt_get(ncin,"time","units")
nt <- dim(time)
nt
tunits

# Get temperature
dname <- "bottomT"

temp_array <- ncvar_get(ncin,dname)
dlname <- ncatt_get(ncin,dname,"long_name")
dunits <- ncatt_get(ncin,dname,"units")
fillvalue <- ncatt_get(ncin,dname,"_FillValue")
dim(temp_array)

# Get global attributes
title <- ncatt_get(ncin,0,"title")
institution <- ncatt_get(ncin,0,"institution")
datasource <- ncatt_get(ncin,0,"source")
references <- ncatt_get(ncin,0,"references")
history <- ncatt_get(ncin,0,"history")
Conventions <- ncatt_get(ncin,0,"Conventions")

# Convert time: split the time units string into fields
tustr <- strsplit(tunits$value, " ")
tdstr <- strsplit(unlist(tustr)[3], "-")
tmonth <- as.integer(unlist(tdstr)[2])
tday <- as.integer(unlist(tdstr)[3])
tyear <- as.integer(unlist(tdstr)[1])

# Here I deviate from the guide a little bit. Save this info:
dates <- chron(time, origin = c(tmonth, tday, tyear))

# Crop the date variable
months <- as.numeric(substr(dates, 2, 3))
years <- as.numeric(substr(dates, 8, 9))
years <- ifelse(years > 90, 1900 + years, 2000 + years)

# Replace netCDF fill values with NA's
temp_array[temp_array == fillvalue$value] <- NA

# Loop through all "dates", put into a list 
dlist <- list()

for(i in 1:length(months)) {
  
  temp_sub <- temp_array[, , i]
  
  dlist[[i]] <- temp_sub
  
}

# Name the list
names(dlist) <- paste(months, years, sep = "_")
str(dlist)

# Create data holding object
temp_data_list <- list()

# Loop through each month_year and extract raster values for the cpue data points
for(i in dat_haul_month_year) {
  
  # Set plot limits
  ymin = 54; ymax = 58; xmin = 12; xmax = 22
  
  # Subset a month-year combination
  temp_slice <- dlist[[i]]
  
  # Create raster for that year (i)
  r <- raster(t(temp_slice), xmn = min(lon), xmx = max(lon), ymn = min(lat), ymx = max(lat),
              crs = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
  
  # Flip...
  r <- flip(r, direction = 'y')
  
  plot(r, main = paste(i), ylim = c(ymin, ymax), xlim = c(xmin, xmax))
  
  # Filter the same year (i) in the cpue data and select only coordinates
  d_slice <- dat_haul %>% filter(month_year == i) %>% dplyr::select(lon, lat)
  
  # Make into a SpatialPoints object
  data_sp <- SpatialPoints(d_slice)
  
  # Extract raster value (oxygen)
  rasValue <- raster::extract(r, data_sp)
  
  # Now we want to plot the results of the raster extractions by plotting the cpue data points over a raster and saving it for each year.
  # Make the SpatialPoints object into a raster again (for plot)
  df <- as.data.frame(data_sp)
  
  # Add in the raster value in the df holding the coordinates for the cpue data
  d_slice$temp <- rasValue
  
  # Add in which year
  d_slice$month_year <- i
  
  # Add each years' data in the list
  temp_data_list[[i]] <- d_slice
}

# Now create a data frame from the list of all annual values
big_dat_temp <- dplyr::bind_rows(temp_data_list)
```

#### Salinity

```{r salinity}
# Open the netCDF file
ncin <- nc_open(paste0(home, "/data/NEMO/cmems_mod_bal_phy_my_P1M-m_1691065974147.nc"))

print(ncin)

# Get longitude and latitude
lon <- ncvar_get(ncin,"lon")
nlon <- dim(lon)
head(lon)

lat <- ncvar_get(ncin,"lat")
nlat <- dim(lat)
head(lat)

# Get time
time <- ncvar_get(ncin,"time")
time

tunits <- ncatt_get(ncin,"time","units")
nt <- dim(time)
nt
tunits

# Get Salinity
dname <- "sob"

sal_array <- ncvar_get(ncin,dname)
dlname <- ncatt_get(ncin,dname,"long_name")
dunits <- ncatt_get(ncin,dname,"units")
fillvalue <- ncatt_get(ncin,dname,"_FillValue")
dim(sal_array)

# Get global attributes
title <- ncatt_get(ncin,0,"title")
institution <- ncatt_get(ncin,0,"institution")
datasource <- ncatt_get(ncin,0,"source")
references <- ncatt_get(ncin,0,"references")
history <- ncatt_get(ncin,0,"history")
Conventions <- ncatt_get(ncin,0,"Conventions")

# Convert time: split the time units string into fields
tustr <- strsplit(tunits$value, " ")
tdstr <- strsplit(unlist(tustr)[3], "-")
tmonth <- as.integer(unlist(tdstr)[2])
tday <- as.integer(unlist(tdstr)[3])
tyear <- as.integer(unlist(tdstr)[1])

# Here I deviate from the guide a little bit. Save this info:
dates <- chron(time, origin = c(tmonth, tday, tyear))

# Crop the date variable
months <- as.numeric(substr(dates, 2, 3))
years <- as.numeric(substr(dates, 8, 9))
years <- ifelse(years > 90, 1900 + years, 2000 + years)

# Replace netCDF fill values with NA's
sal_array[sal_array == fillvalue$value] <- NA

# Loop through all "dates", put into a list 
dlist <- list()

for(i in 1:length(months)) {
  
  sal_sub <- sal_array[, , i]
  
  dlist[[i]] <- sal_sub
  
}

# Name the list
names(dlist) <- paste(months, years, sep = "_")
str(dlist)

# Create data holding object
sal_data_list <- list()

# Loop through each month_year and extract raster values for the cpue data points
for(i in dat_haul_month_year) {
  
  # Set plot limits
  ymin = 54; ymax = 58; xmin = 12; xmax = 22
  
  # Subset a month-year combination
  sal_slice <- dlist[[i]]
  
  # Create raster for that year (i)
  r <- raster(t(sal_slice), xmn = min(lon), xmx = max(lon), ymn = min(lat), ymx = max(lat),
              crs = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
  
  # Flip...
  r <- flip(r, direction = 'y')
  
  plot(r, main = paste(i), ylim = c(ymin, ymax), xlim = c(xmin, xmax))
  
  # Filter the same year (i) in the cpue data and select only coordinates
  d_slice <- dat_haul %>% filter(month_year == i) %>% dplyr::select(lon, lat)
  
  # Make into a SpatialPoints object
  data_sp <- SpatialPoints(d_slice)
  
  # Extract raster value (oxygen)
  rasValue <- raster::extract(r, data_sp)
  
  # Now we want to plot the results of the raster extractions by plotting the cpue data points over a raster and saving it for each year.
  # Make the SpatialPoints object into a raster again (for plot)
  df <- as.data.frame(data_sp)
  
  # Add in the raster value in the df holding the coordinates for the cpue data
  d_slice$sal <- rasValue
  
  # Add in which year
  d_slice$month_year <- i
  
  # Add each years' data in the list
  sal_data_list[[i]] <- d_slice
  
}

# Now create a data frame from the list of all annual values
big_dat_sal <- dplyr::bind_rows(sal_data_list)
```

```{r merge oxygen temp and salinity data with fish data}
env_dat <- left_join(big_dat_oxy, big_dat_temp, by = c("month_year", "lon", "lat")) %>% 
  left_join(big_dat_sal, by = c("month_year", "lon", "lat"))

# Now join these data with the full_dat
dat_env <- dat |> 
  left_join(env_dat, by = c("month_year", "lon", "lat"))
```


## Add in cod density 

```{r cod density covariate}

# for the Mod, the fr data is instead used to scale the prediction grid
data_stats <- read_csv(paste0(home, "/data/clean/data_stats.csv")) 
m3 <- readRDS(paste0(home, file = "/R/main-analysis/m3.rds"))

# d_stats is used to scale the prediction grid when predictiong cod densities
data_stats_st <- data_stats %>% 
  summarise(depth_mean = mean(depth),
            depth_sd = sd(depth),
            sal_mean = mean(sal),
            sal_sd = sd(sal),
            oxy_mean = mean(oxy),
            oxy_sd = sd(oxy),
            temp_mean = mean(temp),
            temp_sd = sd(temp))

df_m3 <- dat_env |>
  drop_na(oxy,
          sal,
          temp) |>
  mutate(depth = ifelse(depth < 0, 0, depth),
         depth_sc = (depth - data_stats_st$depth_mean)/data_stats_st$depth_sd,
         oxy_sc = (oxy - data_stats_st$oxy_mean)/data_stats_st$oxy_sd,
         sal_sc = (sal - data_stats_st$sal_mean)/data_stats_st$sal_sd,
         temp_sc = (temp - data_stats_st$temp_mean)/data_stats_st$temp_sd,
         depth_sq = depth^2,
         temp_sq = temp^2,
         year_f = as.factor(year),
         quarter_f = as.factor(1))

# Predict cod cpue density with model model from Max  
cpue_cod <- predict(m3, newdata = df_m3) |>
  mutate(density_cod = exp(est)) |>
  dplyr::select(lat, lon, month_year, density_cod)

dat <- dat |>
  left_join(cpue_cod, by = c("month_year", "lon", "lat"))

```

```{r save}
# Save data
write_csv(dat_env, paste0(home, "/data/clean/stom_env.csv"))
```
