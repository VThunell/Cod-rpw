---
title: "Saduria feeding ratio fit and effects"
author: "Viktor Thunell (& Max)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    page-layout: full
    embed-resources: true
knitr: 
  opts_chunk:
    fig.align: center
    out-width: 80%
editor: source
execute: 
  echo: true
  eval: true
  cache: true
---

## Load libraries

```{r libs}
#| message: false
#| warning: false
#| cache: false

# Load libraries, install if needed
pkgs <- c("tidyverse", "tidylog", "devtools", "sdmTMB", "sdmTMBextra", "terra", "mapplots",
          "viridis", "visreg", "modelr", "future", "kableExtra", "ggh4x", "patchwork",
          "purrr", "furrr") 

if(length(setdiff(pkgs,rownames(installed.packages()))) > 0){

    install.packages(setdiff(pkgs, rownames(installed.packages())), dependencies = T)
  
  }

invisible(lapply(pkgs, library, character.only = T))

# Import some plotting functions
# Source code for map plots
# You need:
# devtools::install_github("seananderson/ggsidekick") # not on CRAN; library(ggsidekick)
devtools::source_url("https://raw.githubusercontent.com/VThunell/Lammska_cod-fr/main/R/functions/map-plot.R")
options(ggplot2.continuous.colour = "viridis")
#remotes::install_github("pbs-assess/sdmTMBextra", dependencies = TRUE)
# install.packages("remotes")
#remotes::install_github("pbs-assess/sdmTMB", dependencies = TRUE)

library(ggsidekick)
theme_set(theme_sleek())

# Set path
home <- here::here()
```

## Read stomach data and prediction grid

```{r}
#| message: false
#| warning: false
#| cache: false

df <- read_csv(paste0(home, "/data/clean/stom_env.csv")) |>
  mutate(depth_sc = (depth - mean(depth))/sd(depth),
         year_f = as.factor(year),
         month_f = as.factor(month),
         ices_rect = as.factor(ices_rect),
         pred_length_sc = (pred_length - mean(pred_length)) / sd(pred_length),
         doy_sc = ifelse(!is.na(day_of_year), (day_of_year - mean(day_of_year, na.rm = TRUE))/sd(day_of_year, na.rm = TRUE), NA)) |> 
  rowwise() |> 
  mutate(tot = sum(other, other_invert, benth_fish, other_fish, saduria, sprat, herring)
)

glimpse(df)

# pred_grid <- bind_rows(readRDS(paste0(home, "/data/clean/pred_grid_(1_2).rds")),
#                        readRDS(paste0(home, "/data/clean/pred_grid_(2_2).rds")))
pred_grid <- bind_rows(read_csv(paste0(home, "/data/clean/pred_grid_(1_2)_max.csv")),
                       read_csv(paste0(home, "/data/clean/pred_grid_(2_2)_max.csv")))


plot_map +
  geom_raster(data = pred_grid, aes(X*1000, Y*1000, fill = depth))

```


## Filter

```{r}

# remove empty stomachs and day of year that are NA.  0.27 is 99th percentile
q99 <- quantile(df$fr_tot, .99)
df_sad <- df |>
  filter(fr_tot > 0 & fr_tot < q99,
         #between(fr_sad, 0, signif(dfqs$fr_tot[3])),
         !is.na(day_of_year)) |>
  drop_na(oxy,
          sal,
          temp) |>
  mutate(fr_sad_root = fr_sad^(1/2.5), # 1/2 udner estimates, 1/3 over estimates
         decade = round(year/10) * 10,
         year_f = as.factor(year),
         oxy_sc = (oxy - mean(oxy, na.rm = TRUE))/sd(oxy, na.rm = TRUE),
         sal_sc = (sal - mean(sal, na.rm = TRUE))/sd(df$sal, na.rm = TRUE),
         temp_sc = (temp - mean(temp, na.rm = TRUE))/sd(temp, na.rm = TRUE),
         depth_sq = ifelse(!is.na(depth), depth^2, NA),
         density_cod_sc = (density_cod - mean(density_cod))/sd(density_cod),
         temp_sq = temp^2)


```

## Fit spatiotemporal, spatial and not spatial models 

```{r fit Mods}
# fitting without spatial and spatiotemporal effects takes 15 sec, spatial model 20. AR1 spatiotemporal model 4 hours.

# mesh
mesh_tot <- make_mesh(df_sad, c("X", "Y"), cutoff = 6)
 
# reduce number of years to reduce fitting time
# df_sad_sel <- df_sad |> filter( year %in% c(2012:2022))
# mesh_tot_sel <- make_mesh(df_sad, c("X", "Y"), cutoff = 6)

# missing years
my <- min(df_sad$year):max(df_sad$year)
missing_years <- my[!my %in% unique(df_sad$year)]

Mod_n <- 
  sdmTMB(
  data = df_sad,
  formula = fr_sad_root ~ 0 + s(doy_sc, bs = "cc") + depth_sc + sal_sc + temp_sc + oxy_sc + density_cod_sc, 
  time_varying = ~ 1 + pred_length_sc,
  extra_time = missing_years,
  time = "year", 
  mesh = mesh_tot,
  spatial = "off",
  spatiotemporal = "off",
  family = tweedie(link = "log")
)

Mod_s <-
  sdmTMB(
  data = df_sad,
  formula = fr_sad_root ~ 0 + s(doy_sc, bs = "cc") + depth_sc + sal_sc + temp_sc + oxy_sc + density_cod_sc, 
  time_varying = ~ 1 + pred_length_sc,
  extra_time = missing_years,
  time = "year",
  mesh = mesh_tot,
  spatial = "on",
  spatiotemporal = "off",
  family = tweedie(link = "log")
)
 
time <- Sys.time()

Mod <-
  sdmTMB(
  data = df_sad,
  formula = fr_sad_root ~ 0 + s(doy_sc, bs = "cc") + depth_sc + + sal_sc + temp_sc + oxy_sc + density_cod_sc,
  time_varying = ~ 1 + pred_length_sc,
  extra_time = missing_years,
  time = "year",
  mesh = mesh_tot,
  spatial = "on",
  spatiotemporal = "ar1",
  family = tweedie(link = "log"),
)
Sys.time() - time

#saveRDS(Mod, file = paste0("/R/main-analysis/fr-sad_Mod_ar1_env",Sys.Date(),".rds"))
Mod <- readRDS(paste0(home, file = "/R/main-analysis/fr-sad_Mod_ar1_env2024-05-17.rds"))

# rgsim <- simulate(Mod, nsim = 1000, type = 'mle-mvn')
# dharma_residuals(rgsim, Mod) 

sanity(Mod_n)
sanity(Mod_s)
sanity(Mod)

AIC(Mod_n)
AIC(Mod_s)
AIC(Mod) 

# Mod_n_res <- sdmTMBextra::predict_mle_mcmc(Mod_n, mcmc_warmup = 200, mcmc_iter = 201)
# qqnorm(residuals(Mod_n, "mle-mcmc", mcmc_samples = Mod_n_res))
# qqline(residuals(Mod_n, "mle-mcmc", mcmc_samples = Mod_n_res))
# Mod_res <- sdmTMBextra::predict_mle_mcmc(Mod, mcmc_warmup = 200, mcmc_iter = 201)
# qqnorm(residuals(Mod, "mle-mcmc", mcmc_samples = Mod_res))
# qqline(residuals(Mod, "mle-mcmc", mcmc_samples = Mod_res))

#tidy(Mod, effects = "ran_pars", conf.int=TRUE)

```
## Coefficient estimate plot
```{r extract coefficients, message=FALSE}

# Extract random and fixed coefficients from the full model
mfull_est <- bind_rows(tidy(Mod, effects = "ran_par", conf.int = TRUE) |>
                         filter(term %in% c("sigma_O", "sigma_E")),
                       tidy(Mod, effects = "fixed", conf.int = TRUE)  |>
                         filter(!grepl('year', term))) |>
  mutate(term = factor(term))

# Plot effects

# Sort the terms so that random effects are at the top...
mfull_est <- mfull_est %>% 
  mutate(term2 = ifelse(term %in% c("sigma_E", "sigma_O"), 2, 1))

ggplot(mfull_est, aes( estimate, reorder(term, term2))) +
  geom_vline(xintercept = 0, linetype = 2, color = "gray40", alpha = 0.5) +
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high), width = 0) +
  geom_point(size = 2.5) +
  labs(y = "Estimate Saduria", x = "Standardized coefficient") +
  guides(color = "none", fill = "none", shape = guide_legend(ncol = 2))

#ggsave("figures/main/effect_size_sad.pdf", width = 17, height = 12, units = "cm")

```

## Year and Predator length coefficient estimates

```{r plot coefficients for Mod}

# Coefficient estimate of year
Mod_n_tv_est <- as.list(Mod_n$sd_report, "Estimate")
Mod_n_tv_se <- as.list(Mod_n$sd_report, "Std. Error")

Mod_s_tv_est <- as.list(Mod_s$sd_report, "Estimate")
Mod_s_tv_se <- as.list(Mod_s$sd_report, "Std. Error")

Mod_tv_est <- as.list(Mod$sd_report, "Estimate")
Mod_tv_se <- as.list(Mod$sd_report, "Std. Error")

y_n_Mod <- tibble(year = my, coef.est = Mod_n_tv_est$b_rw_t[,1,], coef.se = Mod_n_tv_se$b_rw_t[,1,], model = "nos")
y_s_Mod <- tibble(year = my, coef.est = Mod_s_tv_est$b_rw_t[,1,], coef.se = Mod_s_tv_se$b_rw_t[,1,], model = "spatial")
y_Mod <- tibble(year = my, coef.est = Mod_tv_est$b_rw_t[,1,], coef.se = Mod_tv_se$b_rw_t[,1,], model = "spatiotemporal")

# Coefficient of length varying with year
ypl_Mod_n <- data.frame(year = my, coef.est = Mod_n_tv_est$b_rw_t[,2,], coef.se = Mod_n_tv_se$b_rw_t[,2,], model = "nos")
ypl_Mod_s <- data.frame(year = my, coef.est = Mod_s_tv_est$b_rw_t[,2,], coef.se = Mod_s_tv_se$b_rw_t[,2,], model = "spatial")
ypl_Mod <- data.frame(year = my, coef.est = Mod_tv_est$b_rw_t[,2,], coef.se = Mod_tv_se$b_rw_t[,2,], model = "spatiotemporal")

bind_rows(y_s_Mod, y_n_Mod, y_Mod) |>
  ggplot(aes(year, exp(coef.est)^2.5, color = model, fill = model)) +
  geom_line() +
  geom_ribbon(aes(ymin = exp(coef.est-1.96*coef.se)^2.5, ymax = exp(coef.est+1.96*coef.se)^2.5), color = NA, alpha = 0.3) +
  scale_x_continuous(breaks = seq(min(df_sad$year), max(df_sad$year), by = 10)) +
  ylab("est for year, saduria") # the cf gets very large for the missing year +

bind_rows( ypl_Mod_s, ypl_Mod_n, ypl_Mod) |>
ggplot(aes(year, exp(coef.est)^2.5, fill = model, color = model)) +
  geom_line() +
  geom_ribbon(aes(ymin = exp(coef.est-1.96*coef.se)^2.5, ymax = exp(coef.est+1.96*coef.se)^2.5), color = NA, alpha = 0.3) +
  scale_x_continuous(breaks = seq(min(df_sad$year), max(df_sad$year), by = 10)) +
  ylab("est for pred.length") 

```

<!-- ## Conditional effects  -->

<!-- ```{r conditional fixed effects} -->
<!-- # Conditional effect of depth_sc -->

<!-- nd_dsc <- data.frame(year = 1993, depth_sc = seq(min(df_sad$depth_sc), max(df_sad$depth_sc), length.out = 50), pred_length_sc = 0, doy_sc = 0) -->

<!-- p_n_dsc <- predict(Mod_n, newdata = nd_dsc, re_form = NA, se_fit = TRUE) -->
<!-- p_s_dsc <- predict(Mod_s, newdata = nd_dsc, re_form = NA, se_fit = TRUE) -->
<!-- p_st_dsc <- predict(Mod, newdata = nd_dsc, re_form = NA, se_fit = TRUE) -->

<!-- p_n_dsc$model = "nos"  -->
<!-- p_s_dsc$model = "spatial" -->
<!-- p_st_dsc$model = "spatiotemporal" -->

<!-- bind_rows(p_n_dsc, p_s_dsc, p_st_dsc) |> -->
<!--   ggplot(aes(depth_sc, exp(est)^2.5, color = model, fill = model)) + -->
<!--   geom_line() + -->
<!--   geom_ribbon(aes(ymin = exp(est-1.96*est_se)^2.5, ymax = exp(est+1.96*est_se)^2.5), color = NA, alpha = 0.3) + -->
<!--   ylab("cond. effect depth_sc")  -->

<!-- # Conditional effect of s(doy_sc) -->
<!-- nd_doysc <- data.frame(year = 1993, depth_sc = 0, pred_length_sc = 0, doy_sc = seq(min(df_sad$doy_sc), max(df_sad$doy_sc), length.out = 50)) -->

<!-- p_n_doysc <- predict(Mod_n, newdata = nd_doysc, re_form = NA, se_fit = TRUE) -->
<!-- p_s_doysc <- predict(Mod_s, newdata = nd_doysc, re_form = NA, se_fit = TRUE) -->
<!-- p_st_doysc <- predict(Mod, newdata = nd_doysc, re_form = NA, se_fit = TRUE) -->

<!-- p_s_doysc$doy_sc[which.max(exp(p_s_doysc$est))] # scaled day of maximum fr -->

<!-- p_n_doysc$model = "nos"  -->
<!-- p_s_doysc$model = "spatial" -->
<!-- p_st_doysc$model = "spatiotemporal" -->

<!-- bind_rows(p_n_doysc, p_s_doysc, p_st_doysc) |> # -->
<!--   ggplot(aes(doy_sc, exp(est)^2.5, color = model, fill = model)) + -->
<!--   geom_line() + -->
<!--   geom_ribbon(aes(ymin = exp(est-1.96*est_se)^2.5, ymax = exp(est+1.96*est_se)^2.5), color = NA, alpha = 0.3) + -->
<!--   ylab("cond. effect doy_sc")  -->

<!-- ``` -->


<!-- ```{r conditional effects year} -->

<!-- nd_year <- data.frame(year = my, depth_sc = 0, pred_length_sc = 0, doy_sc = 0) -->

<!-- p_n_year <- predict(Mod_n, newdata = nd_year, re_form = NA, se_fit = TRUE) -->
<!-- p_s_year <- predict(Mod_s, newdata = nd_year, re_form = NA, se_fit = TRUE) -->
<!-- p_st_year <- predict(Mod, newdata = nd_year, re_form = NA, se_fit = TRUE) -->

<!-- p_n_year$model = "nos"  -->
<!-- p_s_year$model = "spatial" -->
<!-- p_st_year$model = "spatiotemporal" -->

<!-- #bind_rows(p_n_year, p_s_year, p_st_year) |> -->
<!-- bind_rows(p_st_year) |> -->
<!--   filter(year >1965)|>  -->
<!--   ggplot(aes(year, exp(est)^2.5, color = model, fill = model)) + -->
<!--   geom_line() + -->
<!--   geom_ribbon(aes(ymin = exp(est-1.96*est_se)^2.5, ymax = exp(est+1.96*est_se)^2.5), color = NA, alpha = 0.3) + -->
<!--   scale_x_continuous(breaks = seq(min(df_sad$year), max(df_sad$year), by = 10)) + -->
<!--   ylab("cond. effect of year") + -->
<!--   ggtitle("Saduria Index") -->

<!-- ``` -->

## Index 

```{r index}
nd_pred_grid <- pred_grid |>
  mutate(depth = ifelse(depth < 0, 0, depth),
         depth_sc = (depth - mean(df_sad$depth))/sd(df_sad$depth),
         doy_sc = 0,
         pred_length_sc = 0,
         oxy_sc = (oxy - mean(df_sad$oxy))/sd(df_sad$oxy),
         sal_sc = (sal - mean(df_sad$sal))/sd(df_sad$sal),
         temp_sc = (temp - mean(df_sad$temp))/sd(df_sad$temp),
         depth_sq = depth^2,
         temp_sq = temp^2,
         year_f = as.factor(year),
         density_cod_sc <- (density_cod - mean(df_sad$density_cod))/sd(df_sad$density_cod)) |>
  drop_na(sal_sc,
          oxy_sc,
          temp_sc,
          temp_sq)

ncells <- filter(nd_pred_grid, year == max(nd_pred_grid$year)) |> nrow()

pred_Mod_n <- predict(Mod_n, newdata = nd_pred_grid, return_tmb_object = TRUE)
pred_Mod_s <- predict(Mod_s, newdata = nd_pred_grid, return_tmb_object = TRUE)
pred_Mod_st <- predict(Mod, newdata = nd_pred_grid, return_tmb_object = TRUE)

index_n <- get_index(pred_Mod_n, area = 1/ncells, bias_correct = TRUE)
index_s <- get_index(pred_Mod_s, area = 1/ncells, bias_correct = TRUE)
index_st <- get_index(pred_Mod_st, area = 1/ncells, bias_correct = TRUE)

index_n$model = "nos" 
index_s$model = "spatial"
index_st$model =s "spatiotempo"

bind_rows(index_n, index_s, index_st)  |> #, 
  ggplot(aes(year, est, color = model, fill = model)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), color = NA, alpha = 0.3) +
  scale_x_continuous(breaks = seq(min(df_sad$year), max(df_sad$year), by = 10)) +
  ylab("index mean") 

```

## Center of gravity

```{r cog spatiotemporal}
cog_st <- #  roughly 1 hour proc time for the st model
  get_cog(
  pred_Mod_s,
  level = 0.95,
  format = "wide",
  area = rep(3, nrow(nd_pred_grid))
)

cog_st <- cog_st |>
  group_by(decade = round(year/10)*10) |>
  mutate(mean_x = mean(est_x),
         mean_y = mean(est_y)) |>
  ungroup() 

ggplot(cog_st, aes(mean_x, mean_y, color = decade )) +
#ggplot(cog_st, aes(est_x, est_y, color = year )) +
  geom_pointrange(aes(xmin = lwr_x, xmax = upr_x)) +
  geom_pointrange(aes(ymin = lwr_y, ymax = upr_y)) +
  scale_colour_viridis_c() +
  labs(title = "center of gravity") +
plot_map_fc +
   geom_pointrange(data = cog_st, aes(est_x*1000, est_y*1000, xmin = lwr_x*1000, xmax = upr_x*1000, colour = decade )) +
   geom_pointrange(data = cog_st, aes(est_x*1000, est_y*1000, ymin = lwr_y*1000, ymax = upr_y*1000, colour = decade )) +
  theme_sleek(base_size = 6) +
  geom_sf()

```

```{r predictions year Mod, eval=FALSE, include=FALSE}
# THE new sdTMB veriosn makes this redundant or if its 
# nd_pred_grid <- pred_grid |>
#   filter(year > 2020 ) |>
#   #filter(year %in% c(2015:2018) ) |>
#   mutate(depth_sc = (depth - mean(df_sad$depth))/sd(df_sad$depth),
#          doy_sc = 0,
#          pred_length_sc = 0)
# 
# ncells <- filter(nd_pred_grid, year == max(nd_pred_grid$year)) |> nrow()
# 
# time <- proc.time()
# #plan(multisession, workers = 2)
# ind <- nd_pred_grid |>
#   split(nd_pred_grid$year) |>
#   map(\(nd) predict(Mod_n, newdata = nd, return_tmb_object = TRUE)) |>
#   map(\(pr) get_index(pr, area = 1/ncells, bias_correct = TRUE)) |>
#   list_rbind()
# #plan(sequential)
# proc.time() - time

# # This works, roughly 1 hour per year. But I dont need map really since im just doing one year at a time.
# time <- proc.time()
# ps = data.frame()
# for (i in 1990:2022) {
# 
#   nd_pred_grid <- pred_grid |>
#   filter( year %in% i ) |>
#   mutate(depth_sc = (depth - mean(df_sad$depth))/sd(df_sad$depth),
#          doy_sc = 0,
#          pred_length_sc = 0)
# 
#   prdi <- nd_pred_grid |>
#       split(nd_pred_grid$year) |>
#       map(\(nd) predict(Mod, newdata = nd, return_tmb_object = TRUE))
# 
#   irdi <- prdi |>
#       map(\(x) get_index(x, area = 1/ncells, bias_correct = TRUE)) |>
#     #future_map(\(pr) get_index(pr, area = 1/ncells, bias_correct = TRUE)) |>
#       list_rbind()#lmap(get_index, area = 1/ncells, bias_correct = TRUE)
# # for two consequitive years, the predictions take 180 sec and the index 5500 sec.
# 
# ps <- bind_rows(ps,irdi) # ad
# 
# # for (i in 1:n) {
# #     # ... make some data
# #     dat <- data.frame(x = rnorm(10), y = runif(10))
# #     dat$i <- i  # maybe you want to keep track of which iteration produced it?
# #     datalist[[i]] <- dat # ad
#   gc()
# }
# 
# proc.time() - time
# 
# 
# time <- proc.time()
# ps = data.frame()
# for (i in 1963:2022) {
# 
#   nd_pred_grid <- pred_grid |>
#   filter( year %in% i ) |>
#   mutate(depth_sc = (depth - mean(df_sad$depth))/sd(df_sad$depth),
#          doy_sc = 0,
#          pred_length_sc = 0)
# 
#   prdi <- predict(Mod_n, newdata = nd_pred_grid, return_tmb_object = TRUE)
#   irdi <- get_index(prdi, area = 1/ncells, bias_correct = TRUE)
#   ps <- bind_rows(ps,irdi) 
#   gc()
# }
# 
# proc.time() - time
# 
# # # model n
# # time <- Sys.time()
# # index_n <- map_dfr(unique(nd_pred_grid$year), \(y) { # backslash means function
# #   nd <- nd_pred_grid |> filter( year == y )
# #   p <- predict(Mod_n, newdata = nd, return_tmb_object = TRUE)
# #   get_index(p, area = 1/ncells, bias_correct = TRUE)
# # })
# # Sys.time() - time
# # 
# # time <- Sys.time()
# # plan(multisession, workers = 4)
# # index_n <- future_map_dfr(unique(nd_pred_grid$year), \(y) { # backslash means function
# #   nd <- nd_pred_grid |> filter( year == y )
# #   p <- predict(Mod_n, newdata = nd, return_tmb_object = TRUE)
# #   get_index(p, area = 1/ncells, bias_correct = TRUE)
# # })
# # plan(sequential)
# # Sys.time() - time
# # # 
# # 
# # ncells <- filter(nd_pred_grid, year == max(nd_pred_grid$year)) |> nrow()
# # 
# # 
# # pred_Mod <- predict(Mod_n, newdata = nd_pred_grid, return_tmb_object = TRUE) # TRUE returns a report from TMB in the 
# # index <- get_index(Pred_Mod, area = rep(1/ncells, nrow(Pred_Mod$data)), bias_correct = TRUE)
# # 
# ps |>
#   ggplot(aes(year, est, fill = model)) +
#   geom_line() +
#   geom_point(shape = 21, alpha = 0.7) +
#   geom_ribbon(aes(ymin = lwr, ymax = upr), color = NA, alpha = 0.4)
```


Size class dependent predictions based on *spatial model* (spatiotemporal index makes R crash or takes too much time).

```{r predictions pred length Mod_s}
nd_sm_pred_grid <- pred_grid |>
   mutate(depth_sc = (depth - mean(df_sad$depth))/sd(df_sad$depth),
          doy_sc = 0,
         pred_length_sc = (20 - mean(df$pred_length))/sd(df$pred_length))
nd_la_pred_grid <- pred_grid |>
   mutate(depth_sc = (depth - mean(df_sad$depth))/sd(df_sad$depth),
          doy_sc = 0,
          pred_length_sc = (50 - mean(df$pred_length))/sd(df$pred_length))

 pred_Mod_m <- predict(Mod_s, newdata = nd_pred_grid, return_tmb_object = TRUE)
 pred_Mod_sm <- predict(Mod_s, newdata = nd_sm_pred_grid, return_tmb_object = TRUE)
 pred_Mod_la <- predict(Mod_s, newdata = nd_la_pred_grid, return_tmb_object = TRUE)

 # Make temporal index!
 ncells <- filter(nd_pred_grid, year == max(nd_pred_grid$year)) |> nrow()
 #??sdmTMB:predict

 index_tot_sm <- get_index(pred_Mod_sm, area = rep(1/ncells, nrow(pred_Mod_sm$data)), bias_correct = TRUE)
 index_tot_la <- get_index(pred_Mod_la, area = rep(1/ncells, nrow(pred_Mod_la$data)), bias_correct = TRUE)
 index_tot_m <- get_index(pred_Mod_m, area = rep(1/ncells, nrow(pred_Mod_m$data)), bias_correct = TRUE)

 bind_rows(index_tot_sm |> mutate(length = "<20"),
           index_tot_m |> mutate(length = "20-50"),
           index_tot_la |> mutate(length = ">50"))  |>
   ggplot(aes(year, est, color = length)) +
   geom_line() +
   #geom_ribbon(aes(ymin = lwr, ymax = upr, alpha = 0.3)) +
   #scale_fill_manual(values = c("white", "grey10")) +
   scale_x_continuous(breaks = seq(min(index_tot_sm$year), max(index_tot_sm$year), by = 10)) +
   ggtitle("predicted est")
   #facet_wrap(~method, scales = "fixed") +
   geom_errorbar(aes(ymin = lwr, ymax = upr), alpha = 0.4, width = 0)

```


## Effect in maps

```{r maps based on spatiotemporal AR1 model (Mod)}
pred_Mod_st$data <- pred_Mod_st$data |>
  group_by(decade = round(year/10)*10, X, Y) |>
  mutate(dec_mean_est = mean(est)) |> # estimate
  mutate(dec_mean_enrf = mean(est_non_rf)) |> # non random (fixed) effects 
  mutate(dec_mean_erf = mean(est_rf)) |> # random spatial
  mutate(dec_mean_eps = mean(epsilon_st)) |> #random spatial and spatiotemporal
  ungroup()

pred_Mod_st$data |>
  pivot_longer(cols = c("est","est_non_rf","est_rf"), names_to = "type", values_to = "vest") |>
  ggplot(aes(exp(vest)^2.5)) +
  facet_wrap(~type, ncol = 2, scales = "free") +
  geom_histogram(bins = 100)

# estimate
plot_map_fc +
  geom_raster(data = pred_Mod_st$data, aes(X*1000, Y*1000, fill = exp(dec_mean_est)^2.5)) +
  facet_wrap(~decade) +
  theme_sleek(base_size = 6) +
  geom_sf() +
  scale_fill_viridis(trans = "sqrt") +
  ggtitle("Estimate, decadal mean estimate")

# Fixed eff, i.e. fr_tot ~ 0 + s(doy_sc, bs = "cc") + depth_sc, time_varying = ~ 1 + pred_length_sc,
plot_map_fc +
  geom_raster(data = pred_Mod_st$data, aes(X*1000, Y*1000, fill = exp(dec_mean_enrf)^2.5)) +
  facet_wrap(~decade) +
  theme_sleek(base_size = 6) +
  geom_sf() +
  scale_fill_viridis(trans = "sqrt") +
  ggtitle("Non random fields, decadal mean estimate")

pred_Mod_st$data |>
  pivot_longer(cols = c("omega_s", "epsilon_st"), names_to = "type", values_to = "vest") |>
  ggplot(aes(exp(vest)^2.5)) +
  facet_wrap(~type, ncol = 2, scales = "free") +
  geom_histogram(bins = 100)

# spatial and spatiotemporal fields
plot_map_fc +
  # geom_raster(data = pred_Mod_st$data, aes(X*1000, Y*1000, fill = est_rf)) +
  # facet_wrap(~year) +
  geom_raster(data = pred_Mod_st$data, aes(X*1000, Y*1000, fill = exp(dec_mean_erf)^2.5)) +
  facet_wrap(~decade) +
  theme_sleek(base_size = 6) +
  geom_sf() +
  scale_fill_viridis() +
  ggtitle("all random fields, decadal mean estimate")

# spatiotemporal fields
plot_map_fc +
  geom_raster(data = pred_Mod_st$data, aes(X*1000, Y*1000, fill = exp(dec_mean_eps)^2.5)) +
  facet_wrap(~decade) +
  theme_sleek(base_size = 6) +
  geom_sf() +
  scale_fill_viridis() +
  ggtitle("spatiotemporal random intercept, decadal mean estimate")

```

